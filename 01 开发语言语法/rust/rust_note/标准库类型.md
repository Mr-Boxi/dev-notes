### Box,栈，堆

所有值默认栈分配，通过Box<T>,把值装箱使它在堆上分配。

被装箱的值可以通过 * 运算符进行解引用

```rust

```

### 动态数组vector

vertor是一个大小可变的数组。类比golang的slice。{指针，长度，容量}

```rust
fn main() {
    // 迭代器可以被收集到vector中
    let collected_iterator: Vec<i32> = (0..10).collect();
    println!("{:?}", collected_iterator);
	
    // vec! 可以用来初始化一个 vertor
    let mut xs = vec![1i32, 2, 3];
    println!("Initial vector: {:?}", xs);
    
    // 在vertor的尾部插入一个元素
    xs.push(4);
    
   	// 报错代码! 不可变vector 不可以增长
    collected_iterator.push(0);
    
    // len 可以获得一个 vector的大小
    xs.len()
    
    // pop 移除最后一个元素，并返回这个移除的值
    xs.pop()
    
    // 超出下标报panic
    
    // 迭代一个 vector 很方便
    for x in xs.iter() {
        println!("{}", x);
    }
    
    // 可以使用i 来记录 迭代次数
    for (i, x) in xs.iter().enumerate() {
        println!("In position {} we have value {}", i, x);
    }
    
    // 使用 iter_mut, 在迭代的同时可以修改每个值
    for x in xs.iter_mut() {
        *x *= 3
    }
}
```

### 字符串 string

rust 中有两种字符串： string  和 &str

String:  存储为vector(Vec<u8>)， 是在堆分配

&str:  是一个指向有效 UTF-8 的序列切片（&[u8]）

```rust
fn main() {
    // 一个对只读内存分配的字符串引用
    let pangram: &' static str = "the quick brown fox jumps over the lazy dog"
    println!("{}", pangram);
    
    // 逆序迭代单词， 这里并没有分配新的字符串
    for word in pangram.split_whitespace().rev() {
        println!("{}", word);
    }
    
    // 复制字符到一个vector, 排序并移除重复值
    let mut chars: Vec<char> = pangram.chars().collect();
    
    chars.sort();
    chars.dedup();
    
    // 创建空的且可以增长的 String
    let mut string = String::new();
    for c in chars {
        string.push(c)
        string.push_str(", ")
    }
    
    // 堆分配一个字符串
    let alice = String::from("i like rust");
    // 分配新的内存并存储修改过的字符串
    let bob: String = alice.replace("rust", "rust_1");
}
```

### 散列表 HashMap

- k, v 键值对

```rust
fn main() {
    let mut contacts = HashMap::new();
    
    contacts.insert("Danile","22");
    contacts.insert("Ashley","23");
    
    // 移除
    contacts.remove(&("Ashley")); 
}
```

- HashSet   HashMap<T, ()>

```rust

```



### 选项 Option 

Option<T> 有两个变体

- None 表示失败或者是缺少值
- Some(value)  元组结构，封装一个T 类型的值

// 解包 `None` 将会引发 `panic!`。

// 解包 `Some` 将取出被包装的值

```rust
// 不会 panic 的整除法
fn checked_division(divided: i32, divisor: i32) -> Option<i32> {
    if divisor == 0 {
        None
    } else {
        Some(divided / divisor)
    }
}

// 处理可能失败的除法
fn try_division(divided: i32, divisor: i32) {
    match checked_division(divided, divisor) {
        None => println!("{} / {} failed!", dividend, divisor),
        Some(quotient) => {
            println!("{} / {} = {}", dividend, divisor, quotient)
        },
    }
}
```

### 结果 Result

Result<T, E>

- Ok(value)  操作成功，并包装操作返回val
- Err(why)  操作失败，并包装 `why`，它（但愿）能够解释失败的原因（`why` 拥有 `E` 类型

```rust
```

### 及早返回运算符号 ?

`?` 运算符用在返回值为 `Result` 的表达式后面，它等同于这样一个匹配 表达式：其中 `Err(err)` 分支展开成提前返回的 `return Err(err)`，而 `Ok(ok)` 分支展开成 `ok` 表达式。

```rust
```

### panic! 

产生一个panic



### 引用计数器 Rc

需要多个所有权时候使用

```rust
```

### 共享引用计数器 Arc

线程之间需要共享时候可以使用Arc (atomic reference counted)

使用clone 方法创建一个引用指针，同时增加引用计数。 

```rust
```



