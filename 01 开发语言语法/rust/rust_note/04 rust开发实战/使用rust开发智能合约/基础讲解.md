经过快速教程开始后，对ink 合约有了大概的了解。下面逐步讲解基础。

### 合约模板

在工作目录下运行(随意)运行

```bash
// 这个命令创建了一份模板合约 foobar，
cargo contract new foobar
cd foobar/
// 修改依赖 Cargo.toml
scale = { package = "parity-scale-codec", version = "3", default-features = false, features = ["derive"] }
scale-info = { version = "2", default-features = false, features = ["derive"], optional = true }

// 检查是否而已通过单元测试
cargo +nightly test
// 检出是否可以编译
cargo +nightly contract build
```

### 存储一些简单的值

```rust
#[ink(storage)]
pub struct MyContract {
       // Store a bool
    my_bool: bool,
    // Store some number
    my_number: u32,
}
```

#### 支持的类型

substrate 合约使用 parity Codec 来编码和解码数据类型，基本涵盖了rust的通用类型。

bool, u{8,16,....}, i{8,16,....}, string, tuples, arrays。



同时也提供了特有的类型，例如 AccountId, Banlance, Hash。举例，以下是存储AccountId 和Balance:

```rust
// 导入默认的 ink! 类型
usr ink_lang ad ink;

#[ink::contract]
mod MyContract {
    
    // 使用 ink! 默认的类型
    #[ink(storage)]
    pub struct MyContract {
        // 存储 账号
        my_account: AccountId,
      	// 存储 余额
        my_balance: Balance,
    }
}
```

### 在构造函数中初始化存储

值的初始化是通过构造函数实现的。每一个合约在被创建的时候会执行构造函数。ink! 合约可以拥有多个构造函数。



如果合约中有 mapping ，则需要使用 `ink_lang::utils::initialize_contract` 。

```rust
use ink_lang as ink;

#[ink::contract]
mod mycontract {
    
    #[inl(storage)]
    pub struct MyContract {
        number: u32,
    }
    
    impl MyContract {
        #[ink(constructor)]
        pub fn new(init_value: u32) -> Self {
            Self {
                number: init_value,
            }
        }
        /// Constructor that initializes the `u32` value to the `u32` default.
        #[ink(constructor)]
        pub fn default() -> Self {
            Self {
                number: Default::default(),
            }
        }
        
    }
}
```

### 从存储中读取值

#### 合约函数

```rust
impl MyContract {
    // 公开 和 私有 的函数都在这里
}
```

#### 公有和私有函数

```rust
impl MyContract {
    /// Public function
    #[ink(message)]
    pub fn my_public_function(&self) {
        /* --snip-- */
    }

    /// Private function
    fn my_private_function(&self) {
        /* --snip-- */
    }

    /* --snip-- */
}
```

所有公开的函数都需要带上 `#[ink(message)]`函数

#### 获取一个值

```rust
impl MyContract {
    #[ink(message)]
    pub fn my_getter(&self) -> u32 {
        self.number
    }
}
```

### 修改存储

可变性与不可变集成了rust语言的特性。如果仅仅是读取值则通过不可变借用`&self`, 如果需要修改存储则通过可变借用`&mut self`

```rust
impl MyContract {
    #[ink(message)]
    pub fn my_getter(&self) -> u32 {
        self.my_number
    }
    
    #[ink(message)]
    pub fn my_setter(&mut self, new_value: u32) {
        self.my_number = new_value
    }
}
```

### 事件

示例

```rust
```

#### 事件定义



#### 在构造函数出发事件



#### 从消息中出发事件



### 特征定义



### 跨合约调用



###  合约测试



### 环境函数

