### 线程

spawn 函数创建本地系统原生线程机制

```rust
use std::thread;

static NTHREAD: i32 = 10;

fn main() {
    // 使用vector 存放子进程
    let mut children = vec![];
    
    for i in 0..NTHREAD {
        // 创建子进程
        children.push(thread::spawn(
        	move || {
                println!("this is thread number {}", i);
            }
        ));
    }
    for child in children {
        // 等待线程结束。返回一个结果
        let _ = child.join();
    }
}
```

- map-reduce



```rust
```



### 管道

线程之间异步通信

```rust
use std::sync::mpsc::{Sender, Receiver};
use std::sync::mpsc;
use std::thread;

static NTHREADS: i32 = 3;

fn main() {
    let (tx, rx): (Sender<i32>, Receiver<i32>) = mpsc::channel();
    for id in 0..NTHREADS {
        // sender 端可以复制
        let thread_tx = tx.clone();
        
        // 每个线程都将通过通道发送id
        thread::spawn(move || {
            //被创建的线程取得thread_tx` 的所有权
            thread_tx.send(id).unwrap();
            
            // 发送是非阻塞操作
            println!("thread {} finished", id);
        });
    }
    
    // 所有消息在此处被收集
    let mut ids = Vec::with_capacity(NTHREADS as usize);
    for _ in 0..NTHREADS {
        ids.push(rx.recv());
    }
    // 显示消息被发送的次序
    println!("{:?}", ids);
}
```



### 子进程

###  路径

`Path` 结构体代表了底层文件系统的文件路径。 posix::path， windows::path

```rust
use std::Path::Path;

fn main() {
    // 从 &‘static str 创建一个 path
    let path = Path::new(".");
    
    // display 显示
    let display = path.display();
    
    // join 使用操作系统的分隔符号合并路径
    let new_path = path.join("a").join("b");  // ./a/b
    
    // 将路径转换成一个字符切片
    match new_path.to_str() {
        None => panic!("new path is not a valid UTF-8 sequence"),
        Some(s) => println!("new path is {}", s),
    }
    
}
```



### 文件输入输出

(1) 打开文件 open

```rust
use std::error::Error;
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

fn main() {
    // 创建指向文件的路径
    let path = Path::new("hello.txt");
    let display = path.display();
    
    // 只读模式打开， 返回io::Result<File>
    let mut file = match Fils::open(&path) {
        Err(why) => panic!("could's read{}:{}", display, why.description()),
        Ok(fils) => file,
    };
    
    // 读取文件中的内容到一个字符串中， 返回 io::Result<usize>
    let mut s = String::new();
    match fils.read_to_string(&mut s) {
        Err(why) => panic!("couldn't read {}: {}", display,
                                                   why.description()),
        Ok(_) => print!("{} contains:\n{}", display, s),
    }
    
    // file 离开作用域， 文件关闭
}
```

（2）创建文件 create

```rust
static LOREM_IPSUM: &'static str =
"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
";

use std::error::Error;
use std::io::prelude::*;
use std::fs:File;
use std::path:Path;

fn mian() {
    let path = Path::new("out/lorem.txt");
    let display = path.display();
    
    // 只写模式打开文件
    let mut file = match File::creat(&path) {
        Err(why) => panic!("couldn't create {}: {}",
                           display,
                           why.description()),
        Ok(file) => file,
    };
    
    // 写进file
    match file.write_all(LOREM_IPSUM.as_bytes()) {
        Err(why) =>{ 
            panic!("couldn't write to {}: {}", display,
                                               why.description())
        },
        Ok(_) => println!("successfully wrote to {}", display),
    }
}
```

(3) 读取行 lines()

```rust
use std::fs::File;
use std::io::(self, BufRead);
use std::path::Path;

fn main() {
    if let Ok(lines) = read_lines("./hosts") {
        for line in lines {
            if let Ok(ip) = line {
                println!("{}", ip);
            }
        }
    }
}
// 输出包裹在 Result 中以允许匹配错误，
// 将迭代器返回给文件行的读取器（Reader）。
fn read_lines<P>(filename: P) -> io::Result<io::Lines<io::BufReader<File>>>
where P: AsRef<Path>, {
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}
```



### 文件系统操作

```rust
```



### 程序参数

- 使用env::args() 获取传入参数

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    
    println!("my path is {}", args[0]);
   
}
```



